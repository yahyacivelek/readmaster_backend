# tests/application/use_cases/test_user_use_cases.py
import pytest
import pytest_asyncio # For async fixtures
from unittest.mock import AsyncMock, MagicMock, patch # For mocking async methods and classes
from uuid import uuid4, UUID
from datetime import datetime, timezone

from readmaster_ai.application.use_cases.user_use_cases import (
    CreateUserUseCase, GetUserProfileUseCase, UpdateUserProfileUseCase, ListUsersUseCase
)
from readmaster_ai.domain.entities.user import DomainUser
from readmaster_ai.domain.value_objects.common_enums import UserRole # Corrected import
from readmaster_ai.domain.repositories.user_repository import UserRepository
from readmaster_ai.presentation.schemas.user_schemas import UserCreateRequest, UserUpdateRequest # DTOs from presentation for now
from readmaster_ai.shared.exceptions import ApplicationException, NotFoundException

@pytest.fixture
def mock_user_repo() -> MagicMock:
    """Fixture to create a MagicMock for UserRepository with async methods."""
    mock = MagicMock(spec=UserRepository) # Use MagicMock for general spec
    # Make repository methods async mocks
    mock.get_by_email = AsyncMock(return_value=None)
    mock.get_by_id = AsyncMock(return_value=None)
    mock.create = AsyncMock(side_effect=lambda user: user) # Default: returns the user passed to it
    mock.update = AsyncMock(side_effect=lambda user: user) # Default: returns the user passed to it
    mock.list_users_paginated = AsyncMock(return_value=([], 0)) # Default for pagination
    return mock

@pytest.fixture
def sample_user_domain() -> DomainUser:
    """Fixture to create a sample DomainUser object for testing."""
    # In a real test, password_hash would be generated by pwd_context.hash()
    # but for domain entity testing, we can use a placeholder.
    return DomainUser(
        user_id=uuid4(),
        email="test.user@example.com",
        password_hash="mocked_hashed_password_from_fixture",
        first_name="Test",
        last_name="User",
        role=UserRole.STUDENT, # Use UserRole enum
        created_at=datetime.now(timezone.utc),
        updated_at=datetime.now(timezone.utc),
        preferred_language="en"
    )

# === Tests for CreateUserUseCase ===
@pytest.mark.asyncio
async def test_create_user_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.get_by_email.return_value = None # Ensure no existing user
    mock_user_repo.create.return_value = sample_user_domain # Mock successful creation

    use_case = CreateUserUseCase(user_repo=mock_user_repo)
    user_create_dto = UserCreateRequest(
        email=sample_user_domain.email,
        password="raw_password123",
        first_name=sample_user_domain.first_name,
        last_name=sample_user_domain.last_name,
        role=sample_user_domain.role.value, # DTO expects string value of enum
        preferred_language=sample_user_domain.preferred_language
    )

    # Act
    # Patch pwd_context.hash within the user_use_cases module for this test's scope
    with patch('src.readmaster_ai.application.use_cases.user_use_cases.pwd_context.hash', return_value="mocked_hashed_password_from_test") as mock_hash:
        created_user = await use_case.execute(user_create_dto)

    # Assert
    mock_user_repo.get_by_email.assert_called_once_with(sample_user_domain.email)
    mock_hash.assert_called_once_with("raw_password123")

    # Check that repo.create was called with a DomainUser instance matching key attributes
    mock_user_repo.create.assert_called_once()
    call_args = mock_user_repo.create.call_args[0][0] # Get the first positional arg (the user object)
    assert isinstance(call_args, DomainUser)
    assert call_args.email == sample_user_domain.email
    assert call_args.password_hash == "mocked_hashed_password_from_test"
    assert call_args.role == sample_user_domain.role # DomainUser uses Enum
    assert call_args.first_name == sample_user_domain.first_name # Ensure other fields are passed

    assert created_user == sample_user_domain # As create mock returns the sample_user_domain

@pytest.mark.asyncio
async def test_create_user_email_exists(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.get_by_email.return_value = sample_user_domain # Simulate email already exists

    use_case = CreateUserUseCase(user_repo=mock_user_repo)
    user_create_dto = UserCreateRequest(
        email=sample_user_domain.email,
        password="password123",
        role=UserRole.STUDENT.value # Provide a role
    )

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(user_create_dto)

    assert exc_info.value.status_code == 409
    assert "Email already registered" in exc_info.value.message
    mock_user_repo.create.assert_not_called() # Ensure create was not called


# === Tests for GetUserProfileUseCase ===
@pytest.mark.asyncio
async def test_get_user_profile_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    use_case = GetUserProfileUseCase(user_repo=mock_user_repo)
    # The current GetUserProfileUseCase simply returns the passed current_user.
    # No repository interaction is strictly needed for its current implementation.

    # Act
    profile = await use_case.execute(current_user=sample_user_domain)

    # Assert
    assert profile == sample_user_domain
    # Verify no unexpected calls to user_repo were made by this simple use case
    mock_user_repo.get_by_id.assert_not_called()

# === Tests for UpdateUserProfileUseCase ===
@pytest.mark.asyncio
async def test_update_user_profile_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    # Create a mutable copy for the test, as the use case modifies the user object
    user_to_update = DomainUser(**sample_user_domain.model_dump(exclude={"updated_at"}))
    user_to_update.updated_at = sample_user_domain.updated_at # Preserve original for comparison

    # Simulate that the new email (if changed) is not taken
    mock_user_repo.get_by_email.return_value = None
    # Simulate that update returns the modified user object
    mock_user_repo.update.side_effect = lambda user_arg: user_arg

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest(
        first_name="UpdatedFirstName",
        last_name="UpdatedLastName",
        email="new.email.updated@example.com",
        preferred_language="es"
    )

    original_updated_at = user_to_update.updated_at

    # Act
    updated_user_result = await use_case.execute(current_user=user_to_update, update_data=update_dto)

    # Assert
    # Check if email validation was called for the new email
    mock_user_repo.get_by_email.assert_called_once_with("new.email.updated@example.com")

    # Check that repo.update was called once
    mock_user_repo.update.assert_called_once()
    updated_user_arg_to_repo = mock_user_repo.update.call_args[0][0] # Get the user obj passed to repo.update

    assert isinstance(updated_user_arg_to_repo, DomainUser)
    assert updated_user_arg_to_repo.first_name == "UpdatedFirstName"
    assert updated_user_arg_to_repo.last_name == "UpdatedLastName"
    assert updated_user_arg_to_repo.email == "new.email.updated@example.com"
    assert updated_user_arg_to_repo.preferred_language == "es"
    assert updated_user_arg_to_repo.user_id == sample_user_domain.user_id # ID should not change
    assert updated_user_arg_to_repo.updated_at > original_updated_at # Timestamp should be updated

    # Check the returned user from the use case
    assert updated_user_result.first_name == "UpdatedFirstName"
    assert updated_user_result.email == "new.email.updated@example.com"

@pytest.mark.asyncio
async def test_update_user_profile_email_conflict(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    conflicting_user_id = uuid4() # Different user ID
    new_email_attempt = "taken.email@example.com"
    # Simulate that the new email is already taken by another user
    mock_user_repo.get_by_email.return_value = DomainUser(
        user_id=conflicting_user_id, email=new_email_attempt,
        password_hash="some_hash", role=UserRole.STUDENT
    )

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest(email=new_email_attempt) # Attempt to update to the taken email

    # Create a mutable copy for the test
    user_to_update = DomainUser(**sample_user_domain.model_dump())

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(current_user=user_to_update, update_data=update_dto)

    assert exc_info.value.status_code == 409
    assert "email is already registered by another user" in exc_info.value.message
    mock_user_repo.update.assert_not_called() # Update should not be called if email conflicts

@pytest.mark.asyncio
async def test_update_user_profile_no_changes_updates_timestamp(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.update.side_effect = lambda user_arg: user_arg # Update returns the passed user

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest() # Empty DTO, meaning no fields are being updated from input

    # Create a mutable copy for the test
    user_to_update = DomainUser(**sample_user_domain.model_dump())
    original_updated_at = user_to_update.updated_at # Capture timestamp before update

    # Act
    updated_user_result = await use_case.execute(current_user=user_to_update, update_data=update_dto)

    # Assert
    mock_user_repo.update.assert_called_once() # Update is still called to persist new updated_at
    updated_user_arg_to_repo = mock_user_repo.update.call_args[0][0]

    # Check that no actual data fields were changed
    assert updated_user_arg_to_repo.first_name == sample_user_domain.first_name
    assert updated_user_arg_to_repo.email == sample_user_domain.email
    # Crucially, updated_at timestamp should have changed
    assert updated_user_arg_to_repo.updated_at > original_updated_at

    assert updated_user_result.updated_at > original_updated_at


# === Tests for ListUsersUseCase ===
@pytest.mark.asyncio
async def test_list_users_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    users_list = [sample_user_domain, DomainUser(user_id=uuid4(), email="user2@example.com", password_hash="hash2", role=UserRole.TEACHER)]
    total_count = len(users_list)
    mock_user_repo.list_users_paginated.return_value = (users_list, total_count)

    use_case = ListUsersUseCase(user_repo=mock_user_repo)
    page, size = 1, 10

    # Act
    result_users, result_total_count = await use_case.execute(page=page, size=size)

    # Assert
    mock_user_repo.list_users_paginated.assert_called_once_with(page=page, size=size)
    assert result_users == users_list
    assert result_total_count == total_count

@pytest.mark.asyncio
async def test_list_users_empty_result(mock_user_repo: MagicMock):
    # Arrange
    mock_user_repo.list_users_paginated.return_value = ([], 0) # Simulate no users found

    use_case = ListUsersUseCase(user_repo=mock_user_repo)
    page, size = 1, 10

    # Act
    result_users, result_total_count = await use_case.execute(page=page, size=size)

    # Assert
    mock_user_repo.list_users_paginated.assert_called_once_with(page=page, size=size)
    assert result_users == []
    assert result_total_count == 0

@pytest.mark.asyncio
@pytest.mark.parametrize("page, size", [
    (0, 10), # Invalid page
    (1, 0),  # Invalid size
    (1, 101) # Invalid size (over max)
])
async def test_list_users_invalid_pagination_parameters(mock_user_repo: MagicMock, page: int, size: int):
    # Arrange
    use_case = ListUsersUseCase(user_repo=mock_user_repo)

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(page=page, size=size)

    assert exc_info.value.status_code == 400
    mock_user_repo.list_users_paginated.assert_not_called()


# === Tests for AdminDeleteUserUseCase ===
from readmaster_ai.application.use_cases.user_use_cases import AdminDeleteUserUseCase

@pytest.fixture
def admin_user_domain(sample_user_domain: DomainUser) -> DomainUser:
    """Fixture for an admin user."""
    admin_user = DomainUser(**sample_user_domain.model_dump(exclude={"role", "user_id"}))
    admin_user.user_id = uuid4() # Ensure different ID from sample_user_domain
    admin_user.role = UserRole.ADMIN
    admin_user.email = "admin@example.com"
    return admin_user

@pytest.fixture
def regular_user_domain(sample_user_domain: DomainUser) -> DomainUser:
    """Fixture for a non-admin user to be deleted."""
    user_to_delete = DomainUser(**sample_user_domain.model_dump(exclude={"user_id"}))
    user_to_delete.user_id = uuid4() # Ensure different ID
    user_to_delete.email = "user.to.delete@example.com"
    user_to_delete.role = UserRole.STUDENT # Explicitly student
    return user_to_delete

@pytest.mark.asyncio
async def test_admin_delete_user_success(mock_user_repo: MagicMock, admin_user_domain: DomainUser, regular_user_domain: DomainUser):
    # Arrange
    mock_user_repo.get_by_id.return_value = regular_user_domain # User to delete exists
    mock_user_repo.delete_by_id.return_value = True # Simulate successful deletion

    use_case = AdminDeleteUserUseCase(user_repo=mock_user_repo)
    user_id_to_delete = regular_user_domain.user_id

    # Act
    await use_case.execute(user_id_to_delete=user_id_to_delete, current_admin_user=admin_user_domain)

    # Assert
    mock_user_repo.get_by_id.assert_called_once_with(user_id_to_delete)
    mock_user_repo.delete_by_id.assert_called_once_with(user_id_to_delete)

@pytest.mark.asyncio
async def test_admin_delete_user_not_found(mock_user_repo: MagicMock, admin_user_domain: DomainUser):
    # Arrange
    non_existent_user_id = uuid4()
    mock_user_repo.get_by_id.return_value = None # Simulate user not found

    use_case = AdminDeleteUserUseCase(user_repo=mock_user_repo)

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(user_id_to_delete=non_existent_user_id, current_admin_user=admin_user_domain)

    assert exc_info.value.status_code == 404
    assert f"User with ID {non_existent_user_id} not found" in exc_info.value.message
    mock_user_repo.delete_by_id.assert_not_called()

@pytest.mark.asyncio
async def test_admin_delete_user_by_non_admin(mock_user_repo: MagicMock, regular_user_domain: DomainUser):
    # Arrange
    non_admin_actor = DomainUser(
        user_id=uuid4(), email="nonadmin@example.com",
        password_hash="hash", role=UserRole.TEACHER # Not an ADMIN
    )
    user_id_to_delete = regular_user_domain.user_id

    use_case = AdminDeleteUserUseCase(user_repo=mock_user_repo)

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(user_id_to_delete=user_id_to_delete, current_admin_user=non_admin_actor)

    assert exc_info.value.status_code == 403
    assert "Forbidden: User does not have admin privileges" in exc_info.value.message
    mock_user_repo.get_by_id.assert_not_called()
    mock_user_repo.delete_by_id.assert_not_called()

@pytest.mark.asyncio
async def test_admin_delete_self_fails(mock_user_repo: MagicMock, admin_user_domain: DomainUser):
    # Arrange
    # Admin tries to delete themselves
    user_id_to_delete = admin_user_domain.user_id
    mock_user_repo.get_by_id.return_value = admin_user_domain # Admin user exists

    use_case = AdminDeleteUserUseCase(user_repo=mock_user_repo)

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(user_id_to_delete=user_id_to_delete, current_admin_user=admin_user_domain)

    assert exc_info.value.status_code == 400
    assert "Admins cannot delete their own accounts" in exc_info.value.message
    mock_user_repo.get_by_id.assert_called_once_with(user_id_to_delete) # get_by_id is called before the self-delete check
    mock_user_repo.delete_by_id.assert_not_called()
