# tests/application/use_cases/test_user_use_cases.py
import pytest
import pytest_asyncio # For async fixtures
from unittest.mock import AsyncMock, MagicMock, patch # For mocking async methods and classes
from uuid import uuid4, UUID
from datetime import datetime, timezone

from src.readmaster_ai.application.use_cases.user_use_cases import (
    CreateUserUseCase, GetUserProfileUseCase, UpdateUserProfileUseCase
)
from src.readmaster_ai.domain.entities.user import User as DomainUser
from src.readmaster_ai.domain.value_objects.common_enums import UserRole # Corrected import
from src.readmaster_ai.domain.repositories.user_repository import UserRepository
from src.readmaster_ai.presentation.schemas.user_schemas import UserCreateRequest, UserUpdateRequest # DTOs from presentation for now
from src.readmaster_ai.shared.exceptions import ApplicationException, NotFoundException

@pytest.fixture
def mock_user_repo() -> MagicMock:
    """Fixture to create a MagicMock for UserRepository with async methods."""
    mock = MagicMock(spec=UserRepository) # Use MagicMock for general spec
    # Make repository methods async mocks
    mock.get_by_email = AsyncMock(return_value=None)
    mock.get_by_id = AsyncMock(return_value=None)
    mock.create = AsyncMock(side_effect=lambda user: user) # Default: returns the user passed to it
    mock.update = AsyncMock(side_effect=lambda user: user) # Default: returns the user passed to it
    return mock

@pytest.fixture
def sample_user_domain() -> DomainUser:
    """Fixture to create a sample DomainUser object for testing."""
    # In a real test, password_hash would be generated by pwd_context.hash()
    # but for domain entity testing, we can use a placeholder.
    return DomainUser(
        user_id=uuid4(),
        email="test.user@example.com",
        password_hash="mocked_hashed_password_from_fixture",
        first_name="Test",
        last_name="User",
        role=UserRole.STUDENT, # Use UserRole enum
        created_at=datetime.now(timezone.utc),
        updated_at=datetime.now(timezone.utc),
        preferred_language="en"
    )

# === Tests for CreateUserUseCase ===
@pytest.mark.asyncio
async def test_create_user_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.get_by_email.return_value = None # Ensure no existing user
    mock_user_repo.create.return_value = sample_user_domain # Mock successful creation

    use_case = CreateUserUseCase(user_repo=mock_user_repo)
    user_create_dto = UserCreateRequest(
        email=sample_user_domain.email,
        password="raw_password123",
        first_name=sample_user_domain.first_name,
        last_name=sample_user_domain.last_name,
        role=sample_user_domain.role.value, # DTO expects string value of enum
        preferred_language=sample_user_domain.preferred_language
    )

    # Act
    # Patch pwd_context.hash within the user_use_cases module for this test's scope
    with patch('src.readmaster_ai.application.use_cases.user_use_cases.pwd_context.hash', return_value="mocked_hashed_password_from_test") as mock_hash:
        created_user = await use_case.execute(user_create_dto)

    # Assert
    mock_user_repo.get_by_email.assert_called_once_with(sample_user_domain.email)
    mock_hash.assert_called_once_with("raw_password123")

    # Check that repo.create was called with a DomainUser instance matching key attributes
    mock_user_repo.create.assert_called_once()
    call_args = mock_user_repo.create.call_args[0][0] # Get the first positional arg (the user object)
    assert isinstance(call_args, DomainUser)
    assert call_args.email == sample_user_domain.email
    assert call_args.password_hash == "mocked_hashed_password_from_test"
    assert call_args.role == sample_user_domain.role # DomainUser uses Enum
    assert call_args.first_name == sample_user_domain.first_name # Ensure other fields are passed

    assert created_user == sample_user_domain # As create mock returns the sample_user_domain

@pytest.mark.asyncio
async def test_create_user_email_exists(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.get_by_email.return_value = sample_user_domain # Simulate email already exists

    use_case = CreateUserUseCase(user_repo=mock_user_repo)
    user_create_dto = UserCreateRequest(
        email=sample_user_domain.email,
        password="password123",
        role=UserRole.STUDENT.value # Provide a role
    )

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(user_create_dto)

    assert exc_info.value.status_code == 409
    assert "Email already registered" in exc_info.value.message
    mock_user_repo.create.assert_not_called() # Ensure create was not called


# === Tests for GetUserProfileUseCase ===
@pytest.mark.asyncio
async def test_get_user_profile_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    use_case = GetUserProfileUseCase(user_repo=mock_user_repo)
    # The current GetUserProfileUseCase simply returns the passed current_user.
    # No repository interaction is strictly needed for its current implementation.

    # Act
    profile = await use_case.execute(current_user=sample_user_domain)

    # Assert
    assert profile == sample_user_domain
    # Verify no unexpected calls to user_repo were made by this simple use case
    mock_user_repo.get_by_id.assert_not_called()

# === Tests for UpdateUserProfileUseCase ===
@pytest.mark.asyncio
async def test_update_user_profile_success(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    # Create a mutable copy for the test, as the use case modifies the user object
    user_to_update = DomainUser(**sample_user_domain.model_dump(exclude={"updated_at"}))
    user_to_update.updated_at = sample_user_domain.updated_at # Preserve original for comparison

    # Simulate that the new email (if changed) is not taken
    mock_user_repo.get_by_email.return_value = None
    # Simulate that update returns the modified user object
    mock_user_repo.update.side_effect = lambda user_arg: user_arg

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest(
        first_name="UpdatedFirstName",
        last_name="UpdatedLastName",
        email="new.email.updated@example.com",
        preferred_language="es"
    )

    original_updated_at = user_to_update.updated_at

    # Act
    updated_user_result = await use_case.execute(current_user=user_to_update, update_data=update_dto)

    # Assert
    # Check if email validation was called for the new email
    mock_user_repo.get_by_email.assert_called_once_with("new.email.updated@example.com")

    # Check that repo.update was called once
    mock_user_repo.update.assert_called_once()
    updated_user_arg_to_repo = mock_user_repo.update.call_args[0][0] # Get the user obj passed to repo.update

    assert isinstance(updated_user_arg_to_repo, DomainUser)
    assert updated_user_arg_to_repo.first_name == "UpdatedFirstName"
    assert updated_user_arg_to_repo.last_name == "UpdatedLastName"
    assert updated_user_arg_to_repo.email == "new.email.updated@example.com"
    assert updated_user_arg_to_repo.preferred_language == "es"
    assert updated_user_arg_to_repo.user_id == sample_user_domain.user_id # ID should not change
    assert updated_user_arg_to_repo.updated_at > original_updated_at # Timestamp should be updated

    # Check the returned user from the use case
    assert updated_user_result.first_name == "UpdatedFirstName"
    assert updated_user_result.email == "new.email.updated@example.com"

@pytest.mark.asyncio
async def test_update_user_profile_email_conflict(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    conflicting_user_id = uuid4() # Different user ID
    new_email_attempt = "taken.email@example.com"
    # Simulate that the new email is already taken by another user
    mock_user_repo.get_by_email.return_value = DomainUser(
        user_id=conflicting_user_id, email=new_email_attempt,
        password_hash="some_hash", role=UserRole.STUDENT
    )

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest(email=new_email_attempt) # Attempt to update to the taken email

    # Create a mutable copy for the test
    user_to_update = DomainUser(**sample_user_domain.model_dump())

    # Act & Assert
    with pytest.raises(ApplicationException) as exc_info:
        await use_case.execute(current_user=user_to_update, update_data=update_dto)

    assert exc_info.value.status_code == 409
    assert "email is already registered by another user" in exc_info.value.message
    mock_user_repo.update.assert_not_called() # Update should not be called if email conflicts

@pytest.mark.asyncio
async def test_update_user_profile_no_changes_updates_timestamp(mock_user_repo: MagicMock, sample_user_domain: DomainUser):
    # Arrange
    mock_user_repo.update.side_effect = lambda user_arg: user_arg # Update returns the passed user

    use_case = UpdateUserProfileUseCase(user_repo=mock_user_repo)
    update_dto = UserUpdateRequest() # Empty DTO, meaning no fields are being updated from input

    # Create a mutable copy for the test
    user_to_update = DomainUser(**sample_user_domain.model_dump())
    original_updated_at = user_to_update.updated_at # Capture timestamp before update

    # Act
    updated_user_result = await use_case.execute(current_user=user_to_update, update_data=update_dto)

    # Assert
    mock_user_repo.update.assert_called_once() # Update is still called to persist new updated_at
    updated_user_arg_to_repo = mock_user_repo.update.call_args[0][0]

    # Check that no actual data fields were changed
    assert updated_user_arg_to_repo.first_name == sample_user_domain.first_name
    assert updated_user_arg_to_repo.email == sample_user_domain.email
    # Crucially, updated_at timestamp should have changed
    assert updated_user_arg_to_repo.updated_at > original_updated_at

    assert updated_user_result.updated_at > original_updated_at
