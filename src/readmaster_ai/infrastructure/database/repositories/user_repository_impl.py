"""
Concrete implementation of the UserRepository interface using SQLAlchemy.
"""
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional
from uuid import UUID

from readmaster_ai.domain.entities.user import User as DomainUser
# UserRole is needed for converting between domain and model
from readmaster_ai.domain.value_objects.common_enums import UserRole
from readmaster_ai.domain.repositories.user_repository import UserRepository
from readmaster_ai.infrastructure.database.models import UserModel # Corrected import


# Helper function for converting SQLAlchemy UserModel to DomainUser
def _user_model_to_domain(model: UserModel) -> Optional[DomainUser]:
    """Converts a UserModel SQLAlchemy object to a DomainUser domain entity."""
    if not model:
        return None
    return DomainUser(
        user_id=model.user_id,
        email=model.email,
        password_hash=model.password_hash, # Ensure this is handled securely and not unnecessarily exposed
        first_name=model.first_name,
        last_name=model.last_name,
        role=UserRole(model.role), # Convert string from DB to Enum
        created_at=model.created_at,
        updated_at=model.updated_at,
        preferred_language=model.preferred_language
    )

class UserRepositoryImpl(UserRepository):
    """
    SQLAlchemy implementation of the user repository.
    """
    def __init__(self, session: AsyncSession):
        self.session = session

    async def get_by_id(self, user_id: UUID) -> Optional[DomainUser]:
        """Retrieves a user by their ID."""
        stmt = select(UserModel).where(UserModel.user_id == user_id)
        result = await self.session.execute(stmt)
        model = result.scalar_one_or_none()
        return _user_model_to_domain(model)

    async def get_by_email(self, email: str) -> Optional[DomainUser]:
        """Retrieves a user by their email address."""
        stmt = select(UserModel).where(UserModel.email == email)
        result = await self.session.execute(stmt)
        model = result.scalar_one_or_none()
        return _user_model_to_domain(model)

    async def create(self, user: DomainUser) -> DomainUser:
        """Creates a new user."""
        model = UserModel(
            user_id=user.user_id, # Assuming UUID is generated in domain or passed if already exists
            email=user.email,
            password_hash=user.password_hash,
            first_name=user.first_name,
            last_name=user.last_name,
            role=user.role.value, # Convert Enum to its string value for DB storage
            preferred_language=user.preferred_language,
            created_at=user.created_at, # Let DB handle defaults if not set in domain
            updated_at=user.updated_at  # Let DB handle defaults if not set in domain
        )
        self.session.add(model)
        await self.session.flush()  # Flush to ensure model.user_id is populated if generated by DB
                                    # and to handle potential DB-level errors before commit.
        await self.session.refresh(model) # Refresh to get all DB-generated values like defaults

        # Convert back to domain entity, now with any DB-generated values
        # (though _user_model_to_domain might need to handle if model.user_id was None initially and now set)
        created_domain_user = _user_model_to_domain(model)
        if created_domain_user is None:
            # This case should ideally not happen if model creation and refresh succeeded.
            # Consider raising an exception or specific error handling.
            raise ValueError("Failed to convert created UserModel back to DomainUser.")
        return created_domain_user
