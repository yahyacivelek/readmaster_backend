"""
Concrete implementation of the ReadingRepository interface using SQLAlchemy.
"""
from typing import Optional, List, Tuple
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update as sqlalchemy_update, delete as sqlalchemy_delete, func, and_

from readmaster_ai.domain.entities.reading import Reading as DomainReading
# DifficultyLevel from domain.entities.reading is the enum definition used by the entity
# DifficultyLevelEnum from value_objects is the one used for type hinting and comparison here
from readmaster_ai.domain.value_objects.common_enums import DifficultyLevel as DifficultyLevelEnum
from readmaster_ai.domain.repositories.reading_repository import ReadingRepository
from readmaster_ai.infrastructure.database.models import ReadingModel
from readmaster_ai.shared.exceptions import ApplicationException # For not found on update/delete


def _reading_model_to_domain(model: ReadingModel) -> Optional[DomainReading]:
    """Converts a ReadingModel SQLAlchemy object to a DomainReading domain entity."""
    if not model:
        return None

    # Ensure difficulty_level from model is valid before converting to Enum
    difficulty_enum_member = None
    if model.difficulty_level:
        try:
            difficulty_enum_member = DifficultyLevelEnum(model.difficulty_level)
        except ValueError:
            # Log this error: data in DB doesn't match Enum definition
            # print(f"Warning: Invalid difficulty_level '{model.difficulty_level}' in DB for reading {model.reading_id}")
            pass # Keep it None or handle as appropriate

    return DomainReading(
        reading_id=model.reading_id,
        title=model.title,
        content_text=model.content_text,
        content_image_url=model.content_image_url,
        age_category=model.age_category,
        difficulty=difficulty_enum_member, # Use the converted enum member
        language=model.language,
        genre=model.genre,
        added_by_admin_id=model.added_by_admin_id,
        created_at=model.created_at,
        updated_at=model.updated_at
        # Questions are typically loaded separately (lazy loading or specific query)
    )

class ReadingRepositoryImpl(ReadingRepository):
    """SQLAlchemy implementation of the reading material repository."""
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, reading: DomainReading) -> DomainReading:
        """Creates a new reading material entry in the database."""
        model = ReadingModel(
            reading_id=reading.reading_id, # Assuming ID is generated by the application/use case
            title=reading.title,
            content_text=reading.content_text,
            content_image_url=reading.content_image_url,
            age_category=reading.age_category,
            difficulty_level=reading.difficulty.value if reading.difficulty else None,
            language=reading.language,
            genre=reading.genre,
            added_by_admin_id=reading.added_by_admin_id,
            created_at=reading.created_at, # Domain entity sets these
            updated_at=reading.updated_at  # Domain entity sets these
        )
        self.session.add(model)
        await self.session.flush()
        await self.session.commit()  # Add commit to persist changes
        await self.session.refresh(model)

        domain_entity = _reading_model_to_domain(model)
        if not domain_entity: # Should not happen if model creation and refresh succeeded
            raise ApplicationException("Failed to map created ReadingModel back to domain entity.", status_code=500)
        return domain_entity

    async def get_by_id(self, reading_id: UUID) -> Optional[DomainReading]:
        """Retrieves a reading material by its ID."""
        stmt = select(ReadingModel).where(ReadingModel.reading_id == reading_id)
        result = await self.session.execute(stmt)
        model = result.scalar_one_or_none()
        return _reading_model_to_domain(model)

    async def list_all(
        self,
        page: int = 1,
        size: int = 20,
        language: Optional[str] = None,
        difficulty: Optional[DifficultyLevelEnum] = None,
        age_category: Optional[str] = None
    ) -> Tuple[List[DomainReading], int]:
        """Lists reading materials with pagination and filters."""
        offset = (page - 1) * size

        conditions = []
        if language:
            conditions.append(ReadingModel.language == language)
        if difficulty:
            conditions.append(ReadingModel.difficulty_level == difficulty.value) # Compare with enum's value
        if age_category:
            conditions.append(ReadingModel.age_category == age_category)

        # Query for fetching the items
        query = select(ReadingModel)
        # Query for counting total matching items
        count_query = select(func.count(ReadingModel.reading_id)).select_from(ReadingModel) # More specific count

        if conditions:
            query = query.where(and_(*conditions))
            count_query = count_query.where(and_(*conditions))

        total_count_result = await self.session.execute(count_query)
        total_count = total_count_result.scalar_one()

        query = query.limit(size).offset(offset).order_by(ReadingModel.created_at.desc())

        result = await self.session.execute(query)
        models = result.scalars().all()

        domain_readings = [_reading_model_to_domain(m) for m in models if _reading_model_to_domain(m) is not None]
        return domain_readings, total_count


    async def update(self, reading: DomainReading) -> Optional[DomainReading]:
        """Updates an existing reading material."""
        if not reading.reading_id:
            # This should be caught by application logic before reaching repository
            raise ValueError("Reading ID must be provided for an update operation.")

        update_data = {
            "title": reading.title,
            "content_text": reading.content_text,
            "content_image_url": reading.content_image_url,
            "age_category": reading.age_category,
            "difficulty_level": reading.difficulty.value if reading.difficulty else None,
            "language": reading.language,
            "genre": reading.genre,
            "updated_at": reading.updated_at, # Domain entity should have updated this
        }

        stmt = (
            sqlalchemy_update(ReadingModel)
            .where(ReadingModel.reading_id == reading.reading_id)
            .values(**update_data)
            .returning(ReadingModel) # Ensures we get the updated model back
        )
        result = await self.session.execute(stmt)
        updated_model = result.scalar_one_or_none()

        if not updated_model:
            # Reading with the given ID was not found.
            # Depending on desired behavior, could raise NotFoundException or return None.
            # For admin CRUD, returning None might be acceptable if "update or fail" is the contract.
            return None

        await self.session.flush() # Ensure the session reflects the update
        # No need to refresh if .returning() fetched all necessary fields.

        domain_entity = _reading_model_to_domain(updated_model)
        if not domain_entity: # Should not happen if model is valid
             raise ApplicationException("Failed to map updated ReadingModel back to domain entity.", status_code=500)
        return domain_entity

    async def delete(self, reading_id: UUID) -> bool:
        """Deletes a reading material by its ID."""
        stmt = sqlalchemy_delete(ReadingModel).where(ReadingModel.reading_id == reading_id)
        result = await self.session.execute(stmt)
        await self.session.commit()
        # await self.session.flush() # Not strictly necessary for delete with autocommit, but good for consistency
                                  # if other operations require flush before checking rowcount.
                                  # However, rowcount is available directly from result.
        return result.rowcount > 0
